#!/bin/bash

# Constants
DISPLAY_RE="([0-9]+)x([0-9]+)\\+([0-9]+)\\+([0-9]+)" # Regex to find display dimensions
FOLDER=$(dirname "$BASH_SOURCE") # Current folder
CACHE_FOLDER="$FOLDER"/img/cache/ # Cache folder
if ! [ -e "$CACHE_FOLDER" ]; then
    mkdir -p "$CACHE_FOLDER"
fi

# Passed arguments
while getopts ":l:a:c:" opt; do
    case $opt in
        l) arg_image="$OPTARG" && cache_only="false"
        ;;
        c) arg_image="$OPTARG" && cache_only="true"
        ;;
        a) lock_args="$OPTARG"
        ;;
        \?) echo "Invalid option -$OPTARG" >&2 && exit 1
        ;;
    esac
done

# Image paths
if [ "$arg_image" ]; then
    BKG_IMG="$arg_image"  # Passed image
else
    BKG_IMG="$FOLDER/img/background.png"  # Default
fi

if ! [ -e "$BKG_IMG" ]; then
    echo "No background image! Exiting..."
    exit 2
fi

MD5_BKG_IMG=$(md5sum "$BKG_IMG" | cut -c 1-10)
MD5_SCREEN_CONFIG=$(xrandr | md5sum - | cut -c 1-32) # Hash of xrandr output
OUTPUT_IMG="$CACHE_FOLDER""$MD5_SCREEN_CONFIG"."$MD5_BKG_IMG".png # Path of final image
OUTPUT_IMG_WIDTH=0 # Decide size to cover all screens
OUTPUT_IMG_HEIGHT=0 # Decide size to cover all screens

# i3lock command
I3LOCK_INSIDE_COLOR=00000000
I3LOCK_RING_COLOR=ffffffff
I3LOCK_KEY_HL_COLOR=d23c3dff
I3LOCK_BSHL_COLOR=d23c3dff
I3LOCK_SEPARATOR_COLOR=00000000
I3LOCK_INSIDE_VER_COLOR=00000000
I3LOCK_INSIDE_WRONG_COLOR=d23c3dff
I3LOCK_RING_VER_COLOR=ffffffff
I3LOCK_RING_WRONG_COLOR=ffffffff
I3LOCK_VERIF_COLOR=ffffffff
I3LOCK_TIME_COLOR=ffffffff
I3LOCK_DATE_COLOR=ffffffff
I3LOCK_LOGINBOX_COLOR=00000066
I3LOCK_FONT="sans-serif"
I3LOCK_DATESTR='%A,%x'
LOCK="$(echo i3lock \
		--timepos='x+110:h-70' \
		--datepos='x+43:h-45' \
		--insidecolor=$I3LOCK_INSIDE_COLOR --ringcolor=$I3LOCK_RING_COLOR --line-uses-inside \
		--keyhlcolor=$I3LOCK_KEY_HL_COLOR --bshlcolor=$I3LOCK_BSHL_COLOR --separatorcolor=$I3LOCK_SEPARATOR_COLOR \
		--insidevercolor=$I3LOCK_INSIDE_VER_COLOR --insidewrongcolor=$I3LOCK_INSIDE_WRONG_COLOR \
		--ringvercolor=$I3LOCK_RING_VER_COLOR --ringwrongcolor=$I3LOCK_RING_WRONG_COLOR --indpos='x+280:h-70' \
		--radius=20 --ring-width=4 --veriftext='' --wrongtext='' \
		--verifcolor=$I3LOCK_VERIF_COLOR --timecolor=$I3LOCK_TIME_COLOR --datecolor=$I3LOCK_DATE_COLOR \
		--time-font=$I3LOCK_FONT --date-font=$I3LOCK_FONT --layout-font=$I3LOCK_FONT \
		--verif-font=$I3LOCK_FONT --wrong-font=$I3LOCK_FONT \
		--clock --date-align 1 \
		--datestr=$I3LOCK_DATESTR \
		--noinputtext='' --force-clock)"

LOCK_BASE_CMD="$LOCK -i $OUTPUT_IMG"

if [ "$lock_args" ]; then
    # Passed command
    LOCK_ARGS="$lock_args"
else
    # Default
    LOCK_ARGS="-t -e"
fi
LOCK_CMD="$LOCK_BASE_CMD $LOCK_ARGS"

if [[ -e "$OUTPUT_IMG" && "$cache_only" == 'false' ]]; then
    # Lock screen since image already exists
    $LOCK_CMD
    exit 0
elif [[ -e "$OUTPUT_IMG" && "$cache_only" == 'true' ]]; then
    echo "Image already converted, doing nothing..."
    exit 0
fi

# Execute xrandr to get information about the monitors:
while read LINE
do
  #If we are reading the line that contains the position information:
  if [[ $LINE =~ $DISPLAY_RE ]]; then
    #Extract information and append some parameters to the ones that will be given to ImageMagick:
    SCREEN_WIDTH=${BASH_REMATCH[1]}
    SCREEN_HEIGHT=${BASH_REMATCH[2]}
    SCREEN_X=${BASH_REMATCH[3]}
    SCREEN_Y=${BASH_REMATCH[4]}
    
    CACHE_IMG="$CACHE_FOLDER""$SCREEN_WIDTH"x"$SCREEN_HEIGHT"."$MD5_BKG_IMG".png
    ## if cache for that screensize doesnt exist
    if ! [ -e $CACHE_IMG ]
    then
	# Create image for that screensize
        eval convert '$BKG_IMG' '-resize' '${SCREEN_WIDTH}X${SCREEN_HEIGHT}^' '-gravity' 'Center' '-crop' '${SCREEN_WIDTH}X${SCREEN_HEIGHT}+0+0' '+repage' '$CACHE_IMG'
    fi

    # Decide size of output image
    if (( $OUTPUT_IMG_WIDTH < $SCREEN_WIDTH+$SCREEN_X )); then OUTPUT_IMG_WIDTH=$(($SCREEN_WIDTH+$SCREEN_X)); fi;
    if (( $OUTPUT_IMG_HEIGHT < $SCREEN_HEIGHT+$SCREEN_Y )); then OUTPUT_IMG_HEIGHT=$(( $SCREEN_HEIGHT+$SCREEN_Y )); fi;

    PARAMS="$PARAMS $CACHE_IMG -geometry +$SCREEN_X+$SCREEN_Y -composite "
  fi
done <<<"`xrandr`"

# Prepare final image
eval convert -size ${OUTPUT_IMG_WIDTH}x${OUTPUT_IMG_HEIGHT} 'xc:black' "$OUTPUT_IMG"

# Apply dim and blur effects
res="${SCREEN_WIDTH}x${SCREEN_HEIGHT}"
blur_level=1
blur_shrink=$(echo "scale=2; 20 / $blur_level" | bc)
blur_sigma=$(echo "scale=2; 0.6 * $blur_level" | bc)

DIMBLUR="-fill black -colorize 40% -filter Gaussian -resize $blur_shrink% -define filter:sigma=$blur_sigma -resize $res^ -gravity center"
eval convert "$OUTPUT_IMG" "$PARAMS" "$DIMBLUR" "$OUTPUT_IMG"

# Apply rectangle beneath time/date OSD
logical_px() {
  # $1: number of pixels to convert
  # $2: 1 for width. 2 for height
	# get dpi value from xrdb
	local DPI
	DPI=""$(xdpyinfo | sed -En "s/\s*resolution:\s*([0-9]*)x([0-9]*)\s.*/\\$2/p" | head -n1)

	# return the default value if no DPI is set
	if [ -z "$DPI" ]; then
		echo "$1"
	else
		local SCALE
		SCALE=$(echo "scale=2; $DPI / 96.0" | bc)

		# check if scaling the value is worthy
		if [ "$(echo "$SCALE > 1.25" | bc -l)" -eq 0 ]; then
			echo "$1"
		else
			echo "$SCALE * $1 / 1" | bc
		fi
	fi
}

rectangles=" "
SR=$(xrandr --query | grep ' connected' | grep -o '[0-9][0-9]*x[0-9][0-9]*[^ ]*')
for RES in $SR; do
	SRA=(${RES//[x+]/ })
	CX=$((SRA[2] + $(logical_px 25 1)))
	CY=$((SRA[1] - $(logical_px 30 2)))
	rectangles+="rectangle $CX,$CY $((CX+$(logical_px 300 1))),$((CY-$(logical_px 80 2))) "
done

RECTANGLE="-draw 'fill #$I3LOCK_LOGINBOX_COLOR $rectangles'"
eval convert "$OUTPUT_IMG" "$RECTANGLE" "$OUTPUT_IMG"

if [[ "$cache_only" == 'true' ]]; then
	echo "Cacheing only, doing nothing..."
else
	$LOCK_CMD
fi
